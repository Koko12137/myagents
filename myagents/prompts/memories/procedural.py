PROCEDURAL_MEMORY_EXTRACT_PROMPT = """
## 程序性记忆提取任务
【从上下文中提取指导性记忆信息，并判断操作类型】

请从当前的上下文中提取**程序性记忆（procedural memory）**，即指导性、命令性内容，包括"做什么、不做什么、怎么做、为什么做、为什么不做"等行动指引。同时需要判断与历史记忆是否存在冲突，并决定相应的操作类型。

### 记忆定义
**程序性记忆**：指导性、命令性内容，包括：
- 操作步骤（如"先混合面粉和鸡蛋"）
- 禁止行为（如"禁止在会议室吸烟"）
- 操作要求（如"烤好后要静置10分钟"）
- 行动指引（如"每天需记录工作进度"）
- 方法说明（如"使用灭火器前需先拔掉保险销"）

### 冲突检测规则
请对比历史记忆与当前上下文，判断是否存在冲突：

1. **步骤冲突**：相同操作但步骤描述不一致（如历史记忆"先加糖后加盐"，当前信息"先加盐后加糖"）
2. **要求冲突**：相同操作但要求不一致（如历史记忆"静置5分钟"，当前信息"静置10分钟"）
3. **方法冲突**：相同目标但方法不一致（如历史记忆"用冷水冲洗"，当前信息"用温水冲洗"）
4. **禁止冲突**：相同行为但禁止状态不一致（如历史记忆"禁止吸烟"，当前信息"允许吸烟"）
5. **原因冲突**：相同操作但原因说明不一致（如历史记忆"为了安全"，当前信息"为了效率"）

### 操作类型判断
- `"add"`：新操作指引，历史记忆中不存在相关内容
- `"update"`：存在冲突，需要用新指引更新历史记忆
- `"delete"`：历史记忆已被新信息替代或证明错误

### 输出格式
请以 **JSONL格式** 输出结果（每行一个独立JSON对象），包含以下字段：

- `operation`：操作类型，取值为 `"add"`、`"update"` 或 `"delete"`
- 当 `operation` 为 `"add"` 或 `"update"` 时，需要包含 `memory` 字段：
  - `memory`：记忆对象，包含以下字段：
    - `memory_type`：固定为 `"procedural_memory"`
    - `content`：提取的程序性内容
    - 可选补充字段（根据内容选择性添加，无需全部包含）：
      - `what`：说明"要做/不要做的具体事项"
      - `how`：说明"操作步骤/方法"
      - `why`：说明"做某事的原因/目的"
      - `whynot`：说明"不做某事的原因/禁止理由"
- 当 `operation` 为 `"delete"` 时，只需要包含 `memory_id` 字段：
  - `memory_id`：要删除的记忆ID（从相似记忆中获取）

### 示例
**历史记忆**：
```json
{"memory_id": 12345, "memory_type": "procedural_memory", "content": "做蛋糕需先加糖后加盐", "what": "加糖和盐", "how": "先加糖后加盐"}
{"memory_id": 12346, "memory_type": "procedural_memory", "content": "蛋糕烤好后要静置5分钟", "what": "静置蛋糕", "how": "静置5分钟"}
{"memory_id": 12347, "memory_type": "procedural_memory", "content": "禁止在会议室吸烟", "what": "禁止的行为：在会议室吸烟", "whynot": "维持会议室环境整洁"}
```

**当前上下文**："做蛋糕需先加盐后加糖。蛋糕烤好后要静置10分钟再脱模，因为热蛋糕容易变形。会议室现在允许吸烟。"

**提取结果**：
```json
{"operation": "update", "memory": {"memory_type": "procedural_memory", "content": "做蛋糕需先加盐后加糖", "what": "加盐和糖", "how": "先加盐后加糖"}}
{"operation": "update", "memory": {"memory_type": "procedural_memory", "content": "蛋糕烤好后要静置10分钟再脱模", "what": "静置蛋糕10分钟再脱模", "how": "静置10分钟", "why": "避免热蛋糕变形"}}
{"operation": "delete", "memory_id": 12347}
```

### 注意事项
- 仔细对比历史记忆与当前信息，准确判断冲突情况
- 根据内容特点选择合适的补充字段
- 确保提取的内容与上下文高度匹配
- 若没有相关程序性记忆，无需输出任何内容
- 操作类型必须准确反映与历史记忆的关系

=============

## 相似记忆
{sim_memories}

=============
现在，请从以下上下文中提取程序性记忆，并判断操作类型：
"""

# 单个程序记忆项的格式化模板
PROCEDURAL_ITEM_FORMAT = """
**程序记忆 {memory_id}**：
{content}

**具体事项**：{what}
**操作步骤**：{how}
**执行原因**：{why}
**禁止原因**：{whynot}

---
"""

# 总体程序记忆组装模板
PROCEDURAL_FORMAT = """
## 历史程序记忆回顾
【基于历史操作指引指导当前任务执行】

以下是相关的历史程序记忆，请参考这些操作指引来指导当前的任务执行：

{memory_items}

### 记忆使用指导
- **操作步骤记忆**：参考历史中的有效操作流程和方法
- **禁止行为记忆**：避免重复历史中禁止或无效的做法
- **执行原因记忆**：理解历史操作背后的逻辑和目的
- **方法说明记忆**：借鉴历史中的具体实施方法

### 执行建议
1. **遵循有效流程**：采用历史中证明有效的操作步骤
2. **避免重复错误**：注意历史中禁止或失败的操作方式
3. **理解操作逻辑**：参考历史操作的原因和目的
4. **灵活应用方法**：结合当前情况，灵活运用历史方法

### 决策要求
**重要提醒**：在参考历史记忆的基础上，请果断做出决策并立即执行。犹豫不决的成本远高于决策失误的代价。基于历史经验，快速选择最合适的操作方案并付诸行动。

请基于以上历史程序记忆，立即为当前任务提供具体的操作指导和执行步骤，并明确下一步的行动方案。
"""
